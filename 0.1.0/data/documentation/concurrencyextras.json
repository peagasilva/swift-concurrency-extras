{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This library comes with a number of tools that make working with Swift concurrency easier and more"},{"type":"text","text":" "},{"type":"text","text":"testable."}]},{"anchor":"ActorIsolated-and-LockIsolated","level":3,"type":"heading","text":"ActorIsolated and LockIsolated"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolated"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated"},{"type":"text","text":" types help wrap other values in an isolated context."},{"type":"text","text":" "},{"type":"codeVoice","code":"ActorIsolated"},{"type":"text","text":" wraps the value in an actor so that the only way to access and mutate the value is"},{"type":"text","text":" "},{"type":"text","text":"through an async\/await interface. "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated"},{"type":"text","text":" wraps the value in a class with a lock, which"},{"type":"text","text":" "},{"type":"text","text":"allows you to read and write the value with a synchronous interface. You should prefer to use"},{"type":"text","text":" "},{"type":"codeVoice","code":"ActorIsolated"},{"type":"text","text":" when you have access to an asynchronous context."}]},{"anchor":"Streams","level":3,"type":"heading","text":"Streams"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with numerous helper APIs spread across the two Swift stream types:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There are helpers that erase any "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":" conformance to either concrete stream type."},{"type":"text","text":" "},{"type":"text","text":"This allows you to treat the stream type as a kind of “type erased” "},{"type":"codeVoice","code":"AsyncSequence"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a dependency client like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct ScreenshotsClient {","  var screenshots: () -> AsyncStream<Void>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then you can construct a live implementation that “erases” the"},{"type":"text","text":" "},{"type":"codeVoice","code":"NotificationCenter.Notifications"},{"type":"text","text":" async sequence to a stream:"}]},{"type":"codeListing","syntax":"swift","code":["extension ScreenshotsClient {","  static let live = Self(","    screenshots: {","      NotificationCenter.default","        .notifications(named: UIApplication.userDidTakeScreenshotNotification)","        .map { _ in }","        .eraseToStream()  \/\/ ⬅️","    }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"eraseToThrowingStream()"},{"type":"text","text":" to propagate failures from throwing async sequences."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There is an API for simultaneously constructing a stream and its backing continuation. This can"},{"type":"text","text":" "},{"type":"text","text":"be handy in tests when overriding a dependency endpoint that returns a stream:"}]},{"type":"codeListing","syntax":"swift","code":["let screenshots = AsyncStream<Void>.streamWithContinuation()","let model = FeatureModel(screenshots: screenshots.stream)","","XCTAssertEqual(model.screenshotCount, 0)","screenshots.continuation.yield()  \/\/ Simulate a screenshot being taken.","XCTAssertEqual(model.screenshotCount, 1)"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"type":"codeVoice","code":"AsyncStream.never"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncThrowingStream.never"},{"type":"text","text":" helpers are provided that represent"},{"type":"text","text":" "},{"type":"text","text":"streams that live forever and never emit. They can be handy in tests that need to override a"},{"type":"text","text":" "},{"type":"text","text":"dependency endpoint with a stream that should suspend and never emit for the duration test."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Static "},{"type":"codeVoice","code":"AsyncStream.finished"},{"type":"text","text":" and "},{"type":"codeVoice","code":"AsyncThrowingStream.finished(throwing:)"},{"type":"text","text":" helpers are provided"},{"type":"text","text":" "},{"type":"text","text":"that represents streams that complete immediately without emitting. They can be handy in tests"},{"type":"text","text":" "},{"type":"text","text":"that need to override a dependency endpoint with a stream that completes\/fails immediately."}]}]}]},{"anchor":"Tasks","level":3,"type":"heading","text":"Tasks"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a static function, "},{"type":"codeVoice","code":"Task.never()"},{"type":"text","text":", that can asynchronously return a value of"},{"type":"text","text":" "},{"type":"text","text":"any type, but does so by suspending forever. This can be useful for satisfying a dependency"},{"type":"text","text":" "},{"type":"text","text":"requirement in a way that does not require you to actually return data from that endpoint."}]},{"anchor":"UncheckedSendable","level":3,"type":"heading","text":"UncheckedSendable"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A wrapper type that can make any type "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":", but in an unsafe and unchecked way. This type"},{"type":"text","text":" "},{"type":"text","text":"should only be used as an alternative to "},{"type":"codeVoice","code":"@preconcurrency import"},{"type":"text","text":", which turns off concurrency"},{"type":"text","text":" "},{"type":"text","text":"checks for everything in the library. Whereas "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"},{"type":"text","text":" allows you to turn off"},{"type":"text","text":" "},{"type":"text","text":"concurrency warnings for just one single usage of a particular type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md"},{"type":"text","text":" mentions future work of "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases"},{"type":"text","text":", including an "},{"type":"codeVoice","code":"UnsafeTransfer"},{"type":"text","text":" type that serves the same"},{"type":"text","text":" "},{"type":"text","text":"purpose, it has not landed in Swift."}]},{"anchor":"Serial-execution","level":3,"type":"heading","text":"Serial execution"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some asynchronous code is "},{"type":"reference","isActive":true,"identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304"},{"type":"text","text":" to test in"},{"type":"text","text":" "},{"type":"text","text":"Swift due to how suspension points are processed by the runtime. The library comes with a static"},{"type":"text","text":" "},{"type":"text","text":"function, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":", that runs all tasks spawned in an operation"},{"type":"text","text":" "},{"type":"text","text":"serially and deterministically. This function can be used to make asynchronous tests faster and less"},{"type":"text","text":" "},{"type":"text","text":"flakey."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that running async tasks serially does not mean that multiple concurrent tasks are not able to"},{"type":"text","text":" "},{"type":"text","text":"interleave. Suspension of async tasks still works just as you would expect, but all tasks are run on"},{"type":"text","text":" "},{"type":"text","text":"the unique, main thread."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, consider the following simple "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" implementation for a feature that"},{"type":"text","text":" "},{"type":"text","text":"wants to count the number of times a screenshot is taken of the screen:"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureModel: ObservableObject {","  @Published var count = 0","  @MainActor","  func onAppear() async {","    let screenshots = NotificationCenter.default.notifications(","      named: UIApplication.userDidTakeScreenshotNotification","    )","    for await _ in screenshots {","      self.count += 1","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is quite a simple feature, but in the future it could start doing more complicated things,"},{"type":"text","text":" "},{"type":"text","text":"such as performing a network request when it detects a screenshot being taken."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, it would be great if we could get some test coverage on this feature. To do this we can create"},{"type":"text","text":" "},{"type":"text","text":"a model, and spin up a new task to invoke the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can use "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" to allow the subscription of the stream of notifications to start:"}]},{"type":"codeListing","syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then we can simulate the user taking a screenshot by posting a notification:"}]},{"type":"codeListing","syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then finally we can yield again to process the new notification and assert that the count"},{"type":"text","text":" "},{"type":"text","text":"incremented by 1:"}]},{"type":"codeListing","syntax":"swift","code":["func testBasics() async {","  let model = ViewModel()","  let task = Task { await model.onAppear() }","","  \/\/ Give the task an opportunity to start executing its work.","  await Task.yield()","","  \/\/ Simulate a screen shot being taken.","  NotificationCenter.default.post(","    name: UIApplication.userDidTakeScreenshotNotification, object: nil","  )","","  \/\/ Give the task an opportunity to update the view model.","  await Task.yield()","","  XCTAssertEqual(model.count, 1)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This seems like a perfectly reasonable test, and it does pass… sometimes. If you run it enough"},{"type":"text","text":" "},{"type":"text","text":"times you will eventually get a failure (about 6% of the time). This is happening because sometimes"},{"type":"text","text":" "},{"type":"text","text":"the single "},{"type":"codeVoice","code":"Task.yield()"},{"type":"text","text":" is not enough for the subscription to the stream of notifications to"},{"type":"text","text":" "},{"type":"text","text":"actually start. In that case we will post the notification before we have actually subscribed,"},{"type":"text","text":" "},{"type":"text","text":"causing a test failure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we wrap the entire test in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":", then it will pass"},{"type":"text","text":" "},{"type":"text","text":"deterministically, 100% of the time:"}]},{"type":"codeListing","syntax":"swift","code":["func testBasics() async {","  await withMainSerialExecutor {","    …","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is because now all tasks are enqueued on the serial, main executor, and so when we "},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" "},{"type":"text","text":"we can be sure that the "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":" method will execute until it reaches a suspension point. This"},{"type":"text","text":" "},{"type":"text","text":"guarantees that the subscription to the stream of notifications will start when we expect it to."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1"},{"type":"text","text":" to wrap an entire test case by"},{"type":"text","text":" "},{"type":"text","text":"overriding the "},{"type":"codeVoice","code":"invokeTest"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["final class FeatureModelTests: XCTestCase {","  override func invokeTest() {","    withMainSerialExecutor {","      super.invokeTest()","    }","  }","  …","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the entire "},{"type":"codeVoice","code":"FeatureModelTests"},{"type":"text","text":" test case will be run on the main, serial executor."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that by using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" you are technically making your"},{"type":"text","text":" "},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"type":"text","text":" "},{"type":"text","text":"tests written on a day-to-day basis due not invoke the full-blown vagaries of concurrency. Instead"},{"type":"text","text":" "},{"type":"text","text":"the tests want to assert that some user action happens, an async unit of work is executed, and"},{"type":"text","text":" "},{"type":"text","text":"that causes some state to change. Such tests should be written in a way that is 100% deterministic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your code has truly complex asynchronous and concurrent operations, then it may be handy to write"},{"type":"text","text":" "},{"type":"text","text":"two sets of tests: one set that targets the main executor (using"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":") so that you can deterministically assert how the core"},{"type":"text","text":" "},{"type":"text","text":"system behaves, and then another set that targets the default, global executor that will probably"},{"type":"text","text":" "},{"type":"text","text":"need to make weaker assertions due to non-determinism, but can still assert on some things."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/concurrencyextras"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"ConcurrencyExtras","title":"ConcurrencyExtras","symbolKind":"module","role":"collection","modules":[{"name":"ConcurrencyExtras"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Data races","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolated","doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated"]},{"title":"Serial execution","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"]},{"title":"Preconcurrency","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable"]}],"references":{"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-79jpc":{"role":"symbol","title":"withMainSerialExecutor(operation:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"rethrows"}],"abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc","kind":"symbol","type":"topic","url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-79jpc"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"role":"collection","title":"ConcurrencyExtras","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","kind":"symbol","type":"topic","url":"\/documentation\/concurrencyextras"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/LockIsolated":{"role":"symbol","title":"LockIsolated","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LockIsolated"}],"abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value with a lock."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/LockIsolated","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LockIsolated"}],"url":"\/documentation\/concurrencyextras\/lockisolated"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-7fqt1":{"role":"symbol","title":"withMainSerialExecutor(operation:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":") "},{"kind":"keyword","text":"rethrows"}],"abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-7fqt1","kind":"symbol","type":"topic","url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-7fqt1"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/ActorIsolated":{"role":"symbol","title":"ActorIsolated","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ActorIsolated"}],"abstract":[{"type":"text","text":"A generic wrapper for isolating a mutable value to an actor."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ActorIsolated","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ActorIsolated"}],"url":"\/documentation\/concurrencyextras\/actorisolated"},"https://forums.swift.org/t/reliably-testing-code-that-adopts-swift-concurrency/57304":{"title":"notoriously difficult","titleInlineContent":[{"type":"text","text":"notoriously difficult"}],"type":"link","identifier":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304","url":"https:\/\/forums.swift.org\/t\/reliably-testing-code-that-adopts-swift-concurrency\/57304"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/UncheckedSendable":{"role":"symbol","title":"UncheckedSendable","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UncheckedSendable"}],"abstract":[{"type":"text","text":"A generic wrapper for turning any non-"},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" type into a "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" one, in an unchecked"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/UncheckedSendable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UncheckedSendable"}],"url":"\/documentation\/concurrencyextras\/uncheckedsendable"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md":{"title":"SE-0302","titleInlineContent":[{"type":"text","text":"SE-0302"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md"},"https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases":{"title":"“Adaptor Types for Legacy Codebases”","titleInlineContent":[{"type":"text","text":"“Adaptor Types for Legacy"},{"type":"text","text":" "},{"type":"text","text":"Codebases”"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0302-concurrent-value-and-concurrent-closures.md#adaptor-types-for-legacy-codebases"}}}