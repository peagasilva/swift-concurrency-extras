{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 5.5 brought first class support for concurrency to the language, including lightweight syntax"},{"type":"text","text":" "},{"type":"text","text":"for describing when functions and methods need to perform async work, a new data type for"},{"type":"text","text":" "},{"type":"text","text":"isolating mutable data, and all new APIs for performing non-blocking asynchronous work. This made it"},{"type":"text","text":" "},{"type":"text","text":"far easier to write async code than ever before, but it also made testing asynchronous code quite"},{"type":"text","text":" "},{"type":"text","text":"a bit more complicated."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Join us for a quick overview of what tools Swift gives us today for testing asynchronous code, as"},{"type":"text","text":" "},{"type":"text","text":"well as examples of how these tools can fall short, and then how to fix them."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This article is a brief recap of a "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code"},{"type":"text","text":" on Point-Free that"},{"type":"text","text":" "},{"type":"text","text":"goes very deep into how to reliably test async code in Swift."}]}],"type":"aside","name":"Note"},{"anchor":"Async-testing-tools-of-today","level":2,"type":"heading","text":"Async testing tools of today"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The primary tool for testing async code today is XCTest’s support for async test cases. Simply mark"},{"type":"text","text":" "},{"type":"text","text":"your test method as "},{"type":"codeVoice","code":"async"},{"type":"text","text":" and then you are free to perform any async work you want:"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureTests: XCTestCase {","  func testBasics() async {","    …","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This makes it easy to invoke an async function or method and then assert on what changed after"},{"type":"text","text":" "},{"type":"text","text":"the work finished."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose we had a very simple observable object for encapsulating a number that could"},{"type":"text","text":" "},{"type":"text","text":"be incremented and decremented from the UI, as well as the ability to fetch a fact about the"},{"type":"text","text":" "},{"type":"text","text":"number. The mechanism for fetching the fact should be hidden behind some kind of interface, like"},{"type":"text","text":" "},{"type":"text","text":"a protocol, but for now we will pass it as an explicit closure to the model."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further, to make things interesting, we will also manage a piece of boolean state that tracks"},{"type":"text","text":" "},{"type":"text","text":"whether or not the fact is currently loading so that we can display a progress indicator in the"},{"type":"text","text":" "},{"type":"text","text":"view:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","@Observable","class FeatureModel {","  var count = 0","  var fact: String?","  var isLoadingFact = false","  ","  \/\/ NB: Can hide this closure behind an interface and use some sort of dependency","  \/\/ injection to provide it.","  let numberFact: (Int) async throws -> String","  init(numberFact: @escaping (Int) async throws -> String) {","    self.numberFact = numberFact","  }","  ","  func getFactButtonTapped() async {","    self.isLoadingFact = true ","    defer { self.isLoadingFact = false }","","    do {","      self.fact = try await self.numberFact(self.count)","    } catch {","      \/\/ TODO: Handle error","    } ","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This model seems simple enough, yet it can be surprisingly tricky to test all aspects of it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The easiest part of the model to test is that the "},{"type":"codeVoice","code":"fact"},{"type":"text","text":" state is populated eventually after the"},{"type":"text","text":" "},{"type":"text","text":"“Get fact” button is tapped. That can be done simply thanks to the support for async in tests, and"},{"type":"text","text":" "},{"type":"text","text":"by using some kind of “mock” version of the number fact closure that returns a response immediately"},{"type":"text","text":" "},{"type":"text","text":"rather than making a network request:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testGetFact() async {","  let model = FeatureModel(numberFact: { number in ","    \"\\(number) is a good number!\" ","  })","  ","  await model.getFactButtonTapped()","  XCAssertEqual(model.fact, \"0 is a good number!\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This test will pass 100% of the time, and do so very quickly. And that’s great!"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What’s not so great is that it’s not really possible to test that the "},{"type":"codeVoice","code":"isLoadingFact"},{"type":"text","text":" state flips"},{"type":"text","text":" "},{"type":"text","text":"from "},{"type":"codeVoice","code":"false"},{"type":"text","text":" to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" and then back to "},{"type":"codeVoice","code":"false"},{"type":"text","text":". At least when using the tools that Swift gives us"},{"type":"text","text":" "},{"type":"text","text":"today for testing async code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First of all, naively asserting on "},{"type":"codeVoice","code":"isLoadingFact"},{"type":"text","text":" right after invoking "},{"type":"codeVoice","code":"getFactButtonTapped"},{"type":"text","text":" can’t"},{"type":"text","text":" "},{"type":"text","text":"possibly work because the async work has already finished by that point:"}]},{"type":"codeListing","syntax":"swift","code":["await model.getFactButtonTapped()","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So what we need to do is run "},{"type":"codeVoice","code":"getFactButtonTapped"},{"type":"text","text":" in an unstructured "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" so that it can run"},{"type":"text","text":" "},{"type":"text","text":"in parallel with the rest of the test. That should allow us to wiggle ourselves in between the"},{"type":"text","text":" "},{"type":"text","text":"moment the boolean state flips to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" and then "},{"type":"codeVoice","code":"false"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let task = Task { await model.getFactButtonTapped() }","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","await task.value","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However this fails the vast majority of times. Over 99% of the time. It seems that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"every"}]},{"type":"text","text":" once in"},{"type":"text","text":" "},{"type":"text","text":"awhile the "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" starts up fast enough to flip the boolean to "},{"type":"codeVoice","code":"true"},{"type":"text","text":", but that is a rare exception"},{"type":"text","text":" "},{"type":"text","text":"rather than the rule."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What we really need to do is wait a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"little"}]},{"type":"text","text":" bit of time for the "},{"type":"codeVoice","code":"Task"},{"type":"text","text":" to start executing its code,"},{"type":"text","text":" "},{"type":"text","text":"but not "},{"type":"emphasis","inlineContent":[{"type":"text","text":"too"}]},{"type":"text","text":" much time so that it finishes. Perhaps a single "},{"type":"codeVoice","code":"Task.yield"},{"type":"text","text":" will help:"}]},{"type":"codeListing","syntax":"swift","code":["let task = Task { await model.getFactButtonTapped() }","await Task.yield()","XCTAssertEqual(model.isLoadingFact, true)  \/\/ ❌","await task.value","XCAssertEqual(model.fact, \"0 is a good number!\")","XCTAssertEqual(model.isLoadingFact, false)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately this fails too, and it does so the vast majority of the time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And this is only one small example of async code that is difficult to test. If your async code"},{"type":"text","text":" "},{"type":"text","text":"tries to implement cancellation, or makes use of time-based asynchrony (such as clocks), or"},{"type":"text","text":" "},{"type":"text","text":"uses async sequences, or any number of things, then you will come across similar test failures that"},{"type":"text","text":" "},{"type":"text","text":"are essentially impossible to fix. You may be able to even get the tests to seemingly pass"},{"type":"text","text":" "},{"type":"text","text":"consistently, but almost alwasy if you run them enough times (thousands or millions of times), you"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"will"}]},{"type":"text","text":" eventually get a test failure, and that breeds uncertainty in your test suite."}]},{"anchor":"Looking-to-Async-Algorithms-for-inspiration","level":2,"type":"heading","text":"Looking to Async Algorithms for inspiration"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, what are we to do?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The problem with testing this kind of async code in Swift is that we have no way to predict how"},{"type":"text","text":" "},{"type":"text","text":"the runtime will schedule and execute work. And that is fine when running the code in production,"},{"type":"text","text":" "},{"type":"text","text":"but we don’t need that complexity for tests. Most tests are verifying a very simple state machine"},{"type":"text","text":" "},{"type":"text","text":"of actions: the user performs a few actions, one after another, and we assert at each step of the"},{"type":"text","text":" "},{"type":"text","text":"way how the state of our feature changes."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In such situations we don’t need the full power of a complex scheduling machine that manages a small"},{"type":"text","text":" "},{"type":"text","text":"pool of threads. It would be completely sufficient to serialize all async work to a single thread."},{"type":"text","text":" "},{"type":"text","text":"That does not mean that multiple concurrent tasks are not able to interleave. Suspension of async"},{"type":"text","text":" "},{"type":"text","text":"tasks can still work as you expect, but all actual work is run serially on a single thread."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And interestingly, there is even a precendent for this in one of Apple’s open source Swift"},{"type":"text","text":" "},{"type":"text","text":"libraries! The "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms"},{"type":"text","text":" package comes with an"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation"},{"type":"text","text":" library with tools specifically designed"},{"type":"text","text":" "},{"type":"text","text":"to make testing async code a deterministic process. It needs this tool in order to write reliable,"},{"type":"text","text":" "},{"type":"text","text":"deterministic tests for its various operators, such as "},{"type":"codeVoice","code":"debounce"},{"type":"text","text":", "},{"type":"codeVoice","code":"throttle"},{"type":"text","text":", and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The way it accomplishes this is by "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"that Swift uses when new asynchronous tasks are created. And that hook is publicly exposed to us"},{"type":"text","text":" "},{"type":"text","text":"from Swift’s actual C++ codebase, which we can see by looking at its "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The async algorithms package uses that global hook to serialize all async work to a single queue"},{"type":"text","text":" "},{"type":"text","text":"rather than let the test be susceptible to the vagaries of the global concurrent executor, allowing"},{"type":"text","text":" "},{"type":"text","text":"it to write tests that pass deterministically, 100% of the time."}]},{"anchor":"How-to-test-async-code-reliably","level":2,"type":"heading","text":"How to test async code reliably?"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And so if Apple can write tests like this, why can’t we?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Well, now we can thanks to the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" tool that ships with"},{"type":"text","text":" "},{"type":"text","text":"this library. It temporarily alters the manner in which Swift enqueues asynchronous work in order"},{"type":"text","text":" "},{"type":"text","text":"to serialize it to the main thread. This allows you to test every facet of the async code, including"},{"type":"text","text":" "},{"type":"text","text":"what happens between each suspension point, in a manner that is 100% deterministic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the previous test we wrote, which passed sometimes but failed most of the times, can"},{"type":"text","text":" "},{"type":"text","text":"now be written in a way that passes 100% of the time:"}]},{"type":"codeListing","syntax":"swift","code":["func testGetFact() async {","  await withMainSerialExecutor {","    let model = FeatureModel(numberFact: { number in","      await Task.yield()","      return \"\\(number) is a good number!\" ","    })","    ","    let task = Task { await model.getFactButtonTapped() }","    await Task.yield()","    XCTAssertEqual(model.isLoadingFact, true)  \/\/ ✅","    await task.value","    XCAssertEqual(model.fact, \"0 is a good number!\")  \/\/ ✅","    XCTAssertEqual(model.isLoadingFact, false)  \/\/ ✅","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because all enqueueing of work has been serialized we can be guaranteed that when we"},{"type":"text","text":" "},{"type":"codeVoice","code":"await Task.yield()"},{"type":"text","text":" in the test, all work that is suspended will have an opportunity to execute"},{"type":"text","text":" "},{"type":"text","text":"before execution is returned to our test. This means this test is guaranteed to always pass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can even override the "},{"type":"codeVoice","code":"invokeTest"},{"type":"text","text":" method in your test case to force every test to run on the"},{"type":"text","text":" "},{"type":"text","text":"main serial executor:"}]},{"type":"codeListing","syntax":"swift","code":["override func invokeTest() {","  withMainSerialExecutor {","    super.invokeTest()","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This tool allows you to finally write tests against complex and subtle async code that you can be"},{"type":"text","text":" "},{"type":"text","text":"confident in. No more seeing mysterious test failures on CI and wasting hours of CI time re-running"},{"type":"text","text":" "},{"type":"text","text":"tests or hours of developer time investigating if they are true errors or simply flakiness in the"},{"type":"text","text":" "},{"type":"text","text":"async scheduling."}]},{"anchor":"Testing-reality","level":2,"type":"heading","text":"Testing reality"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that by using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" you are technically making your"},{"type":"text","text":" "},{"type":"text","text":"tests behave in a manner that is different from how they would run in production. However, many"},{"type":"text","text":" "},{"type":"text","text":"tests written on a day-to-day basis do not invoke the full-blown vagaries of concurrency. Instead,"},{"type":"text","text":" "},{"type":"text","text":"tests often want to assert that when some user action happens, an async unit of work is executed,"},{"type":"text","text":" "},{"type":"text","text":"and that causes some state to change. Such tests should be written in a way that is 100%"},{"type":"text","text":" "},{"type":"text","text":"deterministic. And even Apple agrees in their "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md"},{"type":"text","text":" where they justify why they think their manner of"},{"type":"text","text":" "},{"type":"text","text":"testing async sequences truly does test reality even though they are altering the runtime that"},{"type":"text","text":" "},{"type":"text","text":"schedules async work (emphasis ours):"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"emphasis","inlineContent":[{"type":"text","text":"Testing is a critical area of focus for any package to make it"},{"type":"text","text":" "},{"type":"text","text":"robust, catch bugs, and explain the expected behaviors in a documented manner. Testing things that"},{"type":"text","text":" "},{"type":"text","text":"are asynchronous can be difficult, testing things that are asynchronous multiple times can be even"},{"type":"text","text":" "},{"type":"text","text":"more difficult."}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Types that implement AsyncSequence "},{"type":"strong","inlineContent":[{"type":"text","text":"can often be described in deterministic actions given"},{"type":"text","text":" "},{"type":"text","text":"particular inputs"}]},{"type":"text","text":". For the inputs, the events can be described as a discrete set: values, errors"},{"type":"text","text":" "},{"type":"text","text":"being thrown, the terminal state of returning a nil value from the iterator, or advancing in time"},{"type":"text","text":" "},{"type":"text","text":"and not doing anything. Likewise, the expected output has a discrete set of events: values, errors"},{"type":"text","text":" "},{"type":"text","text":"being caught, the terminal state of receiving a nil value from the iterator, or advancing in time"},{"type":"text","text":" "},{"type":"text","text":"and not doing anything."}]}]}],"type":"aside","name":"Quote from AsyncAlgorithms"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Just as async sequences can often be described with a determinstic sequences of inputs that lead to"},{"type":"text","text":" "},{"type":"text","text":"a deterministic sequence of outputs, the same is true of user actions in an application. And so we"},{"type":"text","text":" "},{"type":"text","text":"too feel that many of the tests we write on a daily basis can be run inside"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":" and that we are not weakening the strength of those"},{"type":"text","text":" "},{"type":"text","text":"tests in the least."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, if your code has truly complex asynchronous and concurrent operations, then it may be handy"},{"type":"text","text":" "},{"type":"text","text":"to write two sets of tests: one set that targets the main executor (using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"so that you can deterministically assert how the core system behaves, and then another set that"},{"type":"text","text":" "},{"type":"text","text":"targets the default, global executor. The latter tests will probably need to make weaker assertions"},{"type":"text","text":" "},{"type":"text","text":"due to non-determinism, but can still assert on some things."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/concurrencyextras\/reliablytestingasync"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/ReliablyTestingAsync","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to use the tools of this library to write reliable, deterministic tests for your async"},{"type":"text","text":" "},{"type":"text","text":"Swift code."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Reliably testing async code","role":"article","modules":[{"name":"ConcurrencyExtras"}]},"hierarchy":{"paths":[["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras"]]},"seeAlsoSections":[{"title":"Serial execution","identifiers":["doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc"],"generated":true}],"references":{"https://github.com/apple/swift-async-algorithms/tree/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation":{"title":"AsyncSequenceValidation","titleInlineContent":[{"type":"codeVoice","code":"AsyncSequenceValidation"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/tree\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation"},"https://github.com/apple/swift-async-algorithms/blob/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation/Test.swift#L319-L321":{"title":"overriding the global enqueue hook","titleInlineContent":[{"type":"text","text":"overriding the global enqueue hook"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/Test.swift#L319-L321"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras/withMainSerialExecutor(operation:)-79jpc":{"role":"symbol","title":"withMainSerialExecutor(operation:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withMainSerialExecutor"},{"kind":"text","text":"("},{"kind":"externalParam","text":"operation"},{"kind":"text","text":": () "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"Void","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"kind":"text","text":" "},{"kind":"keyword","text":"rethrows"}],"abstract":[{"type":"text","text":"Perform an operation on the main serial executor."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras\/withMainSerialExecutor(operation:)-79jpc","kind":"symbol","type":"topic","url":"\/documentation\/concurrencyextras\/withmainserialexecutor(operation:)-79jpc"},"https://www.pointfree.co/collections/concurrency/testing-async-code":{"title":"series of episodes","titleInlineContent":[{"type":"text","text":"series of"},{"type":"text","text":" "},{"type":"text","text":"episodes"}],"type":"link","identifier":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code","url":"https:\/\/www.pointfree.co\/collections\/concurrency\/testing-async-code"},"doc://ConcurrencyExtras/documentation/ConcurrencyExtras":{"role":"collection","title":"ConcurrencyExtras","abstract":[{"type":"text","text":"Useful, testable Swift concurrency."}],"identifier":"doc:\/\/ConcurrencyExtras\/documentation\/ConcurrencyExtras","kind":"symbol","type":"topic","url":"\/documentation\/concurrencyextras"},"https://github.com/apple/swift/blob/e89de6e7e0952c3d0485cc07129ec17f2763c12f/include/swift/Runtime/Concurrency.h#L734-L738":{"title":"headers","titleInlineContent":[{"type":"text","text":"headers"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738","url":"https:\/\/github.com\/apple\/swift\/blob\/e89de6e7e0952c3d0485cc07129ec17f2763c12f\/include\/swift\/Runtime\/Concurrency.h#L734-L738"},"https://github.com/apple/swift-async-algorithms/blob/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5/Sources/AsyncSequenceValidation/AsyncSequenceValidation.docc/AsyncSequenceValidation.md":{"title":"documentation of AsyncSequenceValidation","titleInlineContent":[{"type":"text","text":"documentation of"},{"type":"text","text":" "},{"type":"codeVoice","code":"AsyncSequenceValidation"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md","url":"https:\/\/github.com\/apple\/swift-async-algorithms\/blob\/07a0c1ee08e90dd15b05d45a3ead10929c0b7ec5\/Sources\/AsyncSequenceValidation\/AsyncSequenceValidation.docc\/AsyncSequenceValidation.md"},"https://github.com/apple/swift-async-algorithms":{"title":"Async Algorithms","titleInlineContent":[{"type":"text","text":"Async Algorithms"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-async-algorithms","url":"https:\/\/github.com\/apple\/swift-async-algorithms"}}}